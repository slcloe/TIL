# Item 86 - Serializable을 구현할지는 신중히 결정하기

#### Serializable을 구현하면 릴리즈한 뒤에는 수정하기 어렵다.
* 직렬화 형태로 하나의 공개 API로 취급한다.
* 커스텀 직렬화가 아닌 기본 직렬화를 사용하게 되면 수정하기 어려워진다.
	* 기본 직렬화를 사용했다면,
		1. private, package-private 인스턴스 필드가 API로 공개되는 것과 같다. (캡슐화 위배)
		2. 필드로의 접근을 최대한 막아 정보를 은닉할 수 없다.
* 이후 수정하려고 하면, 구버전 직렬화 인스턴스를 신버전 인스턴스로 역직렬화 하는 과정에서 문제가 발생한다.
* => 따라서, 초기 개발때 신중을 더 가하자!

#### 직렬화가 클래스 개선을 방해하는 예
1. static final long serialVersionUID
	* 직렬화된 클래스의 고유 식별 번호이다.
	* 이 번호를 따로 명시하지 않으면 클래스 구조에 따라 런타임시 결정되는데,
		* 자동으로 생성되는 값에 의존하게 되면 쉽게 호환성이 깨져버린다. ( InvalidClassException )
2. 버그와 보안 위험이 증가한다.
	* 직렬화는 구현된 생성자를 우회하여 객체를 생성할 수 있다.
	* 생성자에서 불변식을 보장해야하지만, 기본 역직렬화를 이용하면 이를 보장할 수 없다.
3. 해당 클래스의 신버전을 릴리즈 할 때 테스트할 것이 늘어난다.
	* 신버전 <-> 구버전 사이의 (역)직렬화가 가능한지 테스트 해야한다.
	* 원래의 객체를 잘 복제할 수 있는지 테스트 해야한다.
	* -> 이 문제는 초기 설계 시 커스텀 직렬화 형태를 잘 설계하면 테스트의 부담을 줄일 수 있다.

#### Serializable의 설계
1. 값 클래스는 Serializable 구현, 동작 클래스는 Serializable 구현 X
2. 상속용으로 설계된 클래스, 인터페이스는 Serializable을 확장하지 말자.
	* 상속받은 클래스 혹은 인터페이스 구현체에게 큰 부담이 된다.
	* 하지만, Seralizable을 구현한 클래스만 지원하는 FW를 사용할 때는 예외이다.
	##### 상속용 Seralizable 클래스
	1. Throwable
		* 클라이언트로 예외를 보내기 위해
	2. Component
		* GUI를 전송, 저장, 복원하기 위해

#### 직렬화 시 주의 점
1. 불변식이 존재한다면, 하위 클래스에서 finalize메서드를 재정의 하지 못하게 하자.
	* finalize 메서드를 자신이 재정의하면서 final 로 선언하게 한다.
2. 인스턴스 필드 중 기본값이 불변식에 위배된다면 readObjectNoData메서드를 추가하자.
```java
private void readObjectNoData() throws InvalidObjectException {
	throw new InvalidObjectException("스트림 데이터가 필요합니다"); 
}	
```

#### 직렬화 하지 않을 때 주의점
* 하위 클래스에서 직렬화가 필요하다면 `직렬화 프록시 패턴`을 사용하자.
* 내부 클래스는 직렬화를 구현하지말자.
	* 내부 클래스의 필드의 클래스 정의는 모호하기 때문에 기본 직렬화의 형태는 알 수 없다.
	* 단, 정적 멤버 클래스는 Seralizable 을 구현해도 된다.

<!--
```java

```
 -->