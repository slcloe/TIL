# Item 85 - 자바 직렬화의 대안을 찾기


#### 객체 직렬화란?
* 자바가 객체를 바이트 스트림으로 인코딩 하는것.
	* (역직렬화 : 바이트 스트림 -> 객체)
* 직렬화된 객체는 다른 vm 으로 전송할 수 있다.
* 디스크에 저장한 후 나중에 역직렬화 할 수 있다.

#### 직렬화의 문제점
**보안상의 공격 범위가 넓고 지속적으로 넓어지고 있어 방어하기가 어렵다.**
* ObjectInputStream.readObject()로 객체를 역직렬화 할 수 있다.
	* 이 함수는, 역직렬화 하는 과정에서 객체의 모든 타입, 코드를 수행할 수 있다.
* 원격 코드 실행(RCE), 서비스 거부(Dos)등의 공격을 받을 수 있다.
* 가젯(Gadget)
	* 역직렬화 과정에서 호출되어 잠재적으로 위험한 동작을 수행하는 메서드
	* 가젯들이 체인으로 엮어서 큰 피해를 본 사례가 있다.
* 역직렬화에 시간이 오래 걸리는 짧은 스트림
	* 역직렬화 폭탄이라고 불린다.
```java
static byte[] bomb() {
	Set<Object> root = new HashSet<>(); 
	Set<Object> s1 = root;
	Set<Object> s2 = new HashSet<>(); 
	
	for (int i = 0; i < 100; i++) {
		Set<Object> t1 = new HashSet<>(); 
		Set<Object> t2 = new HashSet<>(); 
		t1.add("foo"); // t1을 t2와 다르게 만든다. 
		s1.add(t1); s1.add(t2);
		s2.add(t1); s2.add(t2); 
		s1 = t1;
		s2 = t2;
	}
	return serialize(root); // 간결하게 하기 위해 이 메서드의 코드는 생략함 
}
```
* 위 코드의 객체 그래프는 201개의 HashSet 인스턴스, 각각은 3개 이하의 참조 객체를 갖는다.
* HashSet 인스턴스를 역직렬화하기 위해 원소들의 해시코드를 계산하는 과정에서
	* depth 가 100단계 이상 수행된다.
* 이렇게 되면, 무한 루프에 빠질 뿐더러 실행 전에는 오류를 감지 할 수 없다.

#### 역직렬화를 피하자!
* 대신 `크로스-플랫폼 구조화`된 데이터 표현을 쓰자.
	* `(이 책에서 저자가 편의상 쓴 용어지만, 결국 의미하는 것은 객체와 바이스 시퀀스를 변환해주는 다른 매커니즘을 모두 일컫는 말이다.)`
1. JSON
	* 브라우저와 서버의 통신용으로 설계
	* 자바스크립트용
	* 텍스트 기반이라 사람이 읽기 쉽다.

2. 프로토콜 버퍼
	* 구글이 서버 사이에 데이터를 교환하고 저장하기 위해 설계
	* C++용
	* 이진 표현이기 때문에 효율이 높다.

3. 객체 역직렬화 필터링 (java.io.ObjectInputFileter)
* 데이터 스트림이 역직렬화 되기 전에 필터를 거치게 된다.
	* 기본 수용 모드 : 블랙리스트에 기록된 클래스를 거부
	* 기본 거부 모드 : 화이트리스트에 기록된 클래스만 수용
		* 이 방식을 더 추천한다.! ( 블랙리스트 방식은 이미 알려진 위험으로만 보호할 수 있기 때문)
		* SWAT : 화이트리스트를 자동으로 생성해주는 도구
* 필터링을 통해 메모리의 과도한 사용을 방지하고, 객체 depth 가 과도하게 증가하는 것을 보호한다.



<!--
```java

```
 -->