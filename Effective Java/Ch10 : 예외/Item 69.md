# Item 69 - 예외는 진짜 예외 상황에만 사용하기


#### 예외를 잘못 사용한 예시
```java
try {
	int i = 0;
	while(true) 
		range[i++].climb();
} catch (ArrayIndexOutOfBoundsException e) { 

}
```
* 위 코드는 배열원소를 순회하다 오류를 내며 중단한다.
**문제점** 
* for-each 문을 사용하지 않았다. (Item 67)
* 굳이 예외를 사용하지 않아도 되는 상황에서 예외를 사용했다. 
**의도**
* JVM은 배열에 접근할 때마다 경계를 넘지 않는지 검사한다.
* 이 검사를 반복문으로 명시하면 종북되는 작업을 하나 생략할 수 있기에, 성능 개선을 위한 코드로 보인다.

**그럼에도 불구하고 잘못된 코드인 이유**
1. 예외는 예외 상황에 쓸 용도로 설계되었다.
	* 위처럼 명확한 검사보다 빠르게 만들어야할 당위성이 부족하다.
2. try-catch 문을 쓰면 JVM이 적용할 수 있는 최적화가 제한된다.
3. for-each 문 같은 관용구는 중복 검사를 수행하지 않는다.
	* JVM이 알아서 최적화를 해준다.


#### 바른 코드 
```java
for (Mountain m : range) 
	m.climb();
```
* 위 코드를 사용하면 직관성을 높이고 더 안전한 코드를 만들 수 있다.
* 예외는 오직 예외 상황에서만 써야한다.!
* 특히, 성능 개선을 목적으로 쓰지말자, 어차피 자바 플랫폼은 계속 개선되고 있다.

#### 예외 대신 사용할 수 있는 것
##### 1. 상태 검사 메서드
* 예시
```java
for (Iterator<Foo> i = collection.iterator(); i.hasNext(); ) { 
	Foo foo = i.next();
	... 
}
```
* Iterator 인터페이스
	* next : 상태 의존적 메서드
	* hasNext : 상태 검사 메서드
* 만약, hasNext가 없다면 try-catch 문으로 클라이언트가 검사해줘야했다.

##### 2. 옵셔널
##### 3. null 같은 특정값 반환

**사용방법**
1. 외부 동기화 없이 여러 스레드가 동시 접근 가능할 경우 & 가변 객체일 경우

* 옵셔널 혹은 특정 값 사용
	1. 외부 동기화 없이 여러 스레드가 동시 접근 가능한 경우
	2. 외부 요인으로 상태가 변할 수 있는 경우 (가변 객체)
	3. 성능이 중요한 상황에서 상태 검사 메서드가 의존적 메서드의 작업 일부를 중복 수행할 때
* 검사 메서드 사용
	1. 그 외의 경우
	2. 가독성이 더 좋고 잘못 사용했을 시 상태 의존적 메서드가 예외를 던져 바로 확인이 가능하다.


<!--
```java

```
 -->