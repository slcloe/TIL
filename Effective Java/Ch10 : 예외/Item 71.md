# Item 71 - 필요 없는 검사 예외 사용은 피하기 

#### 과한 검사예외의 단점
1. API 사용자에게 부담을 준다.
	* catch 블록을 따로 두거나 바깥으로 던져야하기 때문.
##### 예외상황에 대처하지 못하는 경우
```java
} catch (TheCheckedException e) {
	throw new AssertionError(); // 일어날 수 없다! 
}

} catch (TheCheckedException e) { 
	e.printStackTrace(); // 이런, 우리가 졌다.
	System.exit(1); 
}
```
2. 예외를 던지는 메서드는 스트림 안에서 직접 사용할 수 없다.
3. 메서드가 하나의 검사 예외만 던질 때 부담이 가중된다.
	* 위에 설명했던 catch 블록을 추가해야한다.
	* 스트림에서 직접 사용하지 못한다.
	* -> 하나의 검사예외 떄문에 가져가야할 부담이 너무 많다.

#### 검사 예외를 회피하는 방법
1. Optional 반환
	* 하지만, 예외가 발생한 이류를 알려주는 부가정보를 반환할 수 없다.
2. 검사 예외를 던지는 메서드를 2개로 쪼개서 비검사 예외로 바꾸기
##### 검사 예외 메서드 - 리팩토링 전
```java
try { 
	obj.action(args);
} catch (TheCheckedException e) {
	... // 예외 상황에 대처한다. 
}
```
##### 상태 검사 메서드 & 비검사 예외 메서드 - 리팩토링 후
```java
if (obj.actionPermitted(args)) { // 상태 검사 메서드
	obj.action(args);
} else {
	... // 예외 상황에 대처한다. 
}
```
* 하지만 이는 상태 검사 메서드의 단점도 내포하고 있는 코드이다.
> * 외부 동기화 없이 여러 쓰레드가 동시에 접근 가능한 객체일 경우
> * 외부 요인에 의해 상태가 변할 수 있는 경우
* 상태 검사 메서드와 의존 메서드 호출 사이에 객체의 상태가 변할 수 있다.
* 두 메서드에서 작업 일부를 중복 수행하면 성능면에서 손해다.



<!--
```java

```
 -->