# Item 76 - 가능한 한 실패 원자적으로 만들기

#### 실패 원자성이란?
* 호출된 메서드가 실패하더라도 해당 객체의 상태가 메서드 호출 전 상태를 유지해야한다.
* 만약 실패 원자성을 지키지 못한다면, 실패 시 객체 상태를 API에 문서화 시켜야한다.

#### 메서드를 실패 원자적으로 설계하는 법
##### 1. 불변 객체 설계
* 불변 객체는 실패 원자적이다.
* 불변 객체의 상태는 생성 시점에 고정되기 때문이다.

##### 2. 작업 수행에 앞서 매개변수의 유효성 검사
```java
public Object pop() {
	if (size == 0)
		throw new EmptyStackException();
	Object result = elements[--size]; 
	elements[size] = null; // 다 쓴 참조 해제 
	return result;
}
```
* 처음의 if 문에서 size 값을 확인하여 0 일때, 예외를 던진다.
* 만약 이부분이 없다면, size의 값이 음수가 되고, ArrayIndexOutOfBoundsException 을 던지게 되어 다음번 호출도 실패하게 만든다.

##### 3. 실패할 가능성이 있는 모든 코드를 객체의 상태를 바꾸는 코드보다 앞에 배치하기
* 2번과 비슷한 취지이다.
* TreeMap에 원소를 추가하기 전 엉뚱한 타입의 원소를 추가할 때 타입 검사를 사게 되면 ClassCaseException 을 던져 실패원자성을 지킬 수 있다.

##### 4. 임시 복사본에서 작업을 수행한 후 원래의 객체와 교체하기
* 이 방식은 데이터를 임시의 자료구조에 저장해서 작업하는게 더 빠를 때 적용하면 좋다.
* 정렬 메서드에서 정렬을 수행하기 전 입력 리스트의 원소에 대해 복사본을 만들고
	* 만약, 정렬에 실패했다면 기존 객체를 그대로 쓰면 된다.

##### 5. 작업 도중 실패를 탐지하여 복구 코드를 작성하기
* 주로 디스크 기반의 내구성을 보장해야 하는 자료구조에 쓰인다.
* 자주 쓰이지는 않는다.

#### 실패 원자적으로 설계하지 못했을 때
* 실패 원자적 설계가 불가한 경우
	* 두 스레그가 동기화 없이 같은 객체를 수정한다면
	> ConcurrentModificationException을 던진다.
	> 하지만, 해당 객체의 상태 변동여부를 모르기 때문에 추가적인 검사가 필요하다.
	* Error 를 던질 때
	> 이 경우는 복구할 수 없기 때문에 AssertionError에 대해서는 추가적인 시도가 불가하다.
* 실패원자성을 달성하기 위한 비용 & 복잡도가 아주 큰 연산이 있는 경우

<!--
```java

```
 -->