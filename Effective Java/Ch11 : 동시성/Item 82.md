# Item 82 - 스레드 안정성 수준을 문서화하기

#### synchronized 는 안전하지 않을 수 있다.
* synchronized는 API에 속하지 않기 때문에 반드시 문서화를 시켜야한다.

#### 멀티스레드 환경에서도 API를 안전하게 사용하게 하려면 클래스가 지원하는 스레드 안전성 수준을 정확히 명시해야 한다.
* 불변
	* 상수와 같아서 외부 동기화가 필요없다.
	* ex. String, Long, BigInteger
* 무조건적 스레드 안전
	* 인스턴스는 수정될 수 있다. 하지만 내부 동기화를 통해 외부 동기화가 따로 필요하지 않다.
	* ex. AtomicLong, ConcurrentHashMap
* 조건부 스레드 안전
	* 인스턴스는 수정될 수 있다. 내부동기화를 진행하지만 일부 메서드를 동시에 사용하기 위해서는 외부 동기화가 필요하다.
	* Collections.synchronized 래퍼 메서드가 반환한 컬렉션 (Iterator은 외부 동기화 필수)
* 스레드 안전하지 않음
	* 인스턴스는 수정될 수 있다. 동시에 사용하기 위해서는 외부 동기화 메커니즘이 필요하다.
	* ex. ArrayList, HashMap
* 스레드 적대적
	* 메서드 호출을 외부 동기화로 감싸도 안전하지 않다.
	* 정적 데이터를 동기화 없이 수정한다.
	* 일반적으로 문제를 고쳐 재배포 하거나 Deprecated API 로 지정한다.

#### 조건부 스레드 안전한 클래스의 문서화
1. 어떤 순서로 호출할 때 외부 동기화가 필요한지 문서화 하자.
2. 지정된 순서로 호출하려면 어떤 락이 필요한지 문서화하자.

```java
synchronizedMap이 반환한 맵의 컬렉션 뷰를 순회하려면 반드시 그 맵을 락으로 사용해 수동으로 동기화하라.

Map<K, V> m = Collections.synchronizedMap(new HashMap<>()); 
Set<K> s = m.keySet(); // 동기화 블록 밖에 있어도 된다.
	...
synchronized(m) { // s가 아닌 m을 사용해 동기화해야 한다!
	for (K key : s) 
		key.f();
}

이대로 따르지 않으면 동작을 예측할 수 없다.
```
* 열거 타입은 굳이 불변이라고 쓰지 않아도 된다
* 반환 타입이 불명확한 정적 팩터리라면 반환객체의 스레드 안전성을 반드시 문서화해야한다.

#### 비공개 락 객체 관용구의 문서화
* 내부에서 처리하는 고성능 동시성 제어 메커니즘과 같이 사용할 수 없다.
* ConcurrentHashMap 같은 동시성 컬렉션과는 같이 사용할 수 없다.
* 클라이언트가 공개된 락을 오래 쥐고 놓지 않는 서비스 거부 공격(denial-of-service attack)에 노출되기 쉽다.
	* 이를 막으려면 synchronized 메서드 대신 `비공개 락 객체`를 사용해야한다.

```java
private final Object lock = new Object();
public void foo() { 
	synchronized(lock) {
	... }
}
```
* 비공개 락 객체는 클래스 바깥에서는 볼 수 없으니 클라이언트가 그 객체의 동기화에 관여할 수 없다.
* 앞의 코드에서 lock 필드를 final로 선언했다. => 락 필드의 변경 가능성을 최소화

* `비공개 락 객체 관용구`는 무조건적 스레드 안전 클래스에서만 사용할 수 있다. 
	* 상속 클래스에 사용하기 적합하다.
	* 하지만, 상속용 클래스에서 자신의 인스턴스를 락으로 사용한다면, 하위 클래스는 아주 쉽게 클래스의 동작을 방해할 수 있다
* `조건부 스레드 안전 클래스`에서는 특정 호출 순서에 필요한 락이 무엇인지를 클라이언트에게 알려줘야 하므로 이 관용구를 사용할 수 없다.
	






<!--
```java

```
 -->